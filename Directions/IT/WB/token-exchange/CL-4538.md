https://youtrack.wildberries.ru/issue/CL-4538/Dobavit-otkazoustojchivost-pri-rabote-s-bd
# Описание сервиса token-exchange
Сервис решает следующие задачи:
- Обмен внешнего jwt токена на внутренний  
- Возможность подключения нескольких jwt провайдеров.  
- Создание сервисных токенов.  
- Получение публичного ключа по id для проверки jwt.
Приватный ключ для подписи внутренних jwt смоздается каждый раз при старпте сервиса и хранится только в памяти. Публичный ключ для проверки подписи jwt хранится в Postgres.

# Задача
На данный момент публичный ключ для проверки внутренних jwt хранится в Postgres.
Публичный ключ создается при старте сервиса и по расписанию. Удаляются тольк те ключи срок действия которых истек.
Нужно добавить отказоустойчиваость при работе с Postgres:
- Сервис должен продолжать работать даже при неработающем Postgres.

# Решение
Уже реализован InMemmoryRepository (internal/infrastructure/repository/inmemory) который хранит ключи в кеше, но на данный момент он неактивен.

Я хочу добавить отказоустойчиваость при работе с PostgresRepository с помощью FaultToleranceRepository.

1. FaultToleranceRepository создается в пакете gitlab-private.wildberries.ru/cloud/token-exchange/internal/infrastructure/repository/faulttolerance
2. FaultToleranceRepository имплменетирует методы интерфейса publicKeyRepository
3. NewFaultTolerantPublicKeyRepository использует приватный интерфейс publicKeyRepository для создания inMemmory и Postgres полей.
4. FaultToleranceRepository использует методы Create, Get, DeleteExpired из postgres и inmemmory repository в зависимости от ситуации.
5. При Create запись создается сначала в InMemmory, потом в Postgres.
6. Если при Create Postgres недоступна или превышен контекст таймаут записи (по умолчанию 500 милисекунд) выставляется.
7. При Get:
	1. Сначала смотрим в Postgres, потом в Inmemmory.
	2. Когда берем ключ из Postgres проверяем есть ли он в Inmemmoryе и пишем туда если нет.  
8. DeleteExpired всегда отрабатывает для Postgres и Inmemmory если что-то из этого выдало ошибку пишем простой лог slog и идем дальше.
9. При неработающей Postgres стартуем с одним публичным ключем который генерится вначале.
10. Нужно чтобы все сценарии работы FaultToleranceRepository можно было замокать и покрыть юнит тестами. Для этого FaultToleranceRepository должен исползовать приватный интерфейс publicKeyRepository для моков и методы декомпозированы для простых юнит тестов.
11. На данный момент не нужно писать логи или тесты, это будет в следующей задаче.
12. Каждый метод должен быть кратко прокоментирован.

Интерфейс publicKeyRepository реализуемые FaultTolerance, InMemmory и Psotgres Repository: 
```
type publicKeyRepository interface {  
    Create(ctx context.Context, publicKey domain.PublicKey) error  
    Get(ctx context.Context, id string) (*domain.PublicKey, error)  
    DeleteExpired(ctx context.Context) error  
}
```

# TODO:
1. Покрыть все тестами
2. Логирование.
3. На будущее (в другой таске) - ввести механизм try\retry который будет отмечать доступность Postgres чтобы не дергать Postgres каждый раз даже если она недостуна.
# Вопросы
Ниже перечислил моменты, по которым нужна дополнительная ясность, чтобы реализация FaultToleranceRepository точно соответствовала ожиданиям.

Вот ответы на уточнияющие вопросы которые ты задал ранее. 
"""
1. **Буфер «отложенных» ключей (Create, когда Postgres недоступен)**
    - Какой механизм flush-а предусмотреть: фиксированный интервал (например, раз в N секунд) или экспоненциальный back-off? - фиксированный интервал
    - Нужен ли лимит на размер очереди? - не нужен.
        
2. **Контекст-таймауты**  
    У Postgres-репозитория заданы константы `insertTimeout`, `selectTimeout`, `execTimeout` .
    Для FaultToleranceRepository собственные (более короткие), по умолчанию 500ms.
        
3. **Метод GetAll**  
    Этот метод не нужен, его просто забыли удалить.
        
4. **Обновление InMemory при чтении из Postgres**  
    В п. 7.2 написано «пишем туда, если нет» – достаточно ли простого `Create`, или важно перезаписывать, когда версия в Postgres свежее (например, изменён срок действия)?
	 - Достаточно простого Create
    
5. **Удаление просроченных ключей**  
    При недоступном Postgres вызываем `DeleteExpired` только для InMemory или всё-таки пытаемся сначала в Postgres с таймаутом, а затем — в памяти?
    - Всегда сначала пытаемся выполнить действие в Postgres с таймаутом, и только потом в InMemmory
    
6. **Логирование и метрики**
     - пока обойдемся без логов и метрик.
        
7. **Горутина для начальной генерации ключа, если Postgres не стартовал (п. 11)**
    - Верно ли понимать, что генерация выполняется там же, где инициализируется FaultToleranceRepository, и сразу помещает ключ в InMemory?
    - да, верно.
        
    - Как поступать, если при последующих рестартах Postgres опять «лежит», а в памяти уже есть устаревший ключ?
    - никак, просто теряем устаревише ключи в памяти. это окей.
        
8. **Тесты**
    - Достаточно unit-тестов на FaultToleranceRepository c замоканным Postgres-репозиторием и InMemory-репозиторием, или нужны интеграционные тесты с реальным Postgres в docker-compose?
    - достаточно unit тестов.
9. **Зависимость от nowFunc**  
	InMemory-репозиторий принимает функцию времени .
	- Передавать её дальше из FaultToleranceRepository или использовать `time.Now` напрямую, а InMemory оставить как есть?
	- Передавать из FaultToleranceRepository
"""
Учти эти ответы и присутпи к выполнению задачи по реализации FaultToleranceRepository

Напиши мне subtest для табличного теста TestPublicKeyRepository_StandardScenario который выполнял бы следующую логику:
1. Создается ключ, postgres работает, ключ попадает туда
2. Запрашиваем ключ, postgres не работает, этот же ключ берется из inmemmory.
3. Создаем новый ключ, он должен попасть и inmemmory и в pendingWrites так как postgres всё ещё не работает.
4. pendingWrites орабатывает первый раз, postgres не отвечает, ключ остается в pendingWrites
5. pendingWrites отрабатывает второй раз и ключ кладется в postgres.
6. Проверяем что новый ключ лежит в postgres а также сохраняется в inmemmory.

Это должен быть код который можно было бы вставить в структуру tests в методе TestPublicKeyRepository_StandardScenario

Наверное стоит для pendingWrites использовать отдельный инстанс inmemmory
Надо делать полный синк и выставлять флаг что его надо сделать при нудачном c create в базу.


1. При конкурентном доступе флаг `needSync` может быть установлен/сброшен некорректно, что приведет к потере данных или избыточным синхронизаиям.
2. Если Postgres недоступен, ключ остается в memory, но метод возвращает ошибку. Это может ввести в заблуждение вызывающую сторону.
3. **Неконсистентное поведение `DeleteExpired`**. Если Postgres упал, но memory очистился успешно, система все равно возвращает ошибку.


Если в memory есть более свежая версия ключа, она будет перезаписана старой версией из Postgres.

Истекшие ключи из memory могут быть синхронизированы в Postgres.