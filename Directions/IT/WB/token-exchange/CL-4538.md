https://youtrack.wildberries.ru/issue/CL-4538/Dobavit-otkazoustojchivost-pri-rabote-s-bd

Добавить отказоустойчиваость при работе с бд:

- Сервис должен продолжать работать даже при неработающей бд.
- Ничгео не менять на уровне usecases.

Кэш должен:

- скачивать себе все публичные ключи из бд
- записывать в бд новые ключи
- иметь логику обработки недоступность бд
```
                                              Cache
                                                ^
                                                |
                                                v
                  Usecases <-->  FaultToleranceRepository
                                                ^
                                                |
                                                v
                                           Postgres

```

# Добавить отказоустойчиваость при работе с бд
1. FaultToleranceRepository создается в cmd/server/main.go:createRepositories
2. FaultToleranceRepository использует методы Create, Get, DeleteExpired из postgres и inmemmory repository в зависимости от ситуации.
3. При Create запись создается и в БД и в кеше (inmemmory)
4. Пре Get:
	1. Если БД доступна запись берется из неё
	2. Если БД не доступна запись берется из кеша
	3. Когда берем ключ из БД проверяем есть ли он в кеше и пишем туда если нет.  
5. Нужен метод на проверку доступности БД
6. Сервис должен мочь стартовать при неработающей БД

Интерфейс publicKeyRepository реализуемые FaultTolerance, InMemmory и Psotgres Repository: 
```
type publicKeyRepository interface {  
    Create(ctx context.Context, publicKey domain.PublicKey) error  
    Get(ctx context.Context, id string) (*domain.PublicKey, error)  
    DeleteExpired(ctx context.Context) error  
}
```

# Обновленный план GPT 4.1
Here is an improved plan considering the identified issues and possible solutions:

**1. Repository Layer Design**
- Implement `FaultToleranceRepository` that wraps both Postgres and in-memory repositories.
- All access goes through this repository, which handles fallback and synchronization logic.

**2. Data Consistency & Synchronization**
- On `Create`, if DB is unavailable, store the key in a "pending sync" list in memory.
- Periodically (background goroutine), try to sync pending keys to the DB when it becomes available.
- On `Get`, if DB is unavailable, read from cache. If found in DB but not in cache, update cache.
- On `DeleteExpired`, if DB is unavailable, remove expired keys from cache and mark for later DB cleanup.

**3. Service Startup**
- On startup, if DB is available, load all public keys into cache.
- If DB is unavailable, start with an empty cache and log a warning.

**4. DB Availability Check**
- Implement a fast, non-blocking health check for DB status.
- Cache DB status for a short period to avoid frequent checks.

**5. Memory Management**
- Limit cache size and implement LRU or TTL-based eviction.
- Ensure expired keys are regularly purged from cache.

**6. Error Handling & Logging**
- Log all DB failures, cache misses, and sync attempts.
- Expose metrics for monitoring cache/DB health and sync backlog.

**7. Testing & Edge Cases**
- Write tests for DB failover, recovery, and data reconciliation scenarios.
- Test service restart with DB down and up.

**8. Thread Safety**
- Use mutexes or concurrent-safe structures for in-memory cache and pending sync list.

**9. Reconciliation After DB Recovery**
- After DB becomes available, reconcile:  
  - Sync pending keys.
  - Clean up expired keys in DB and cache.

**10. Documentation**
- Document failover, recovery, and reconciliation logic for maintainers.

This plan addresses data loss, consistency, memory growth, and operational transparency.

# Sonet 3.7:
## Task: Implement Fault Tolerance for Database Operations in Token Exchange Service

## Overview
Create a fault-tolerant repository pattern for public keys that ensures the service continues to operate even when the database is unavailable, without modifying the usecases layer.

## Technical Requirements

### 1. Create `FaultTolerantPublicKeyRepository` Implementation

Create a new repository in a file `internal/infrastructure/repository/faulttolerance/public_key.go` that:
- Implements the `publicKeyRepository` interface
- Uses both PostgreSQL and in-memory repositories for redundancy
- Handles database unavailability gracefully

### 2. Implementation Details

#### Constructor
```go
func NewFaultTolerantPublicKeyRepository(
    postgresRepo *postgres.PublicKeyRepository,  // Can be nil if DB is unavailable
    inMemoryRepo *inmemory.PublicKeyRepository,
) *FaultTolerantPublicKeyRepository
```

#### Core Methods
1. **Create Method**:
   - Attempt to create in PostgreSQL first
   - Always create in in-memory store
   - Return success if at least one succeeded

2. **Get Method**:
   - Try to get from PostgreSQL first
   - Fall back to in-memory if DB is unavailable
   - If retrieved from DB, ensure it's cached in-memory
   - Return appropriate error if not found in either store

3. **DeleteExpired Method**:
   - Try to delete expired keys from PostgreSQL
   - Always delete expired keys from in-memory cache
   - Continue operation even if DB operation fails

#### Helper Methods
1. **isPostgresAvailable**: Checks if PostgreSQL is accessible
2. **loadKeysFromPostgres**: Loads all public keys from PostgreSQL into memory
3. **syncToInMemory**: Ensures a key from PostgreSQL exists in in-memory cache

### 3. Service Startup Logic

Modify `createRepositories` in `cmd/server/main.go` to:
- Attempt to connect to PostgreSQL if enabled
- Create in-memory repository regardless of PostgreSQL status
- Create fault-tolerant repository with both repositories (PostgreSQL can be nil)
- Load existing keys from PostgreSQL into memory cache on startup (if available)

### 4. Error Handling

- Log database connectivity issues but continue operation
- Return operation-specific errors to caller, not database connection errors
- Ensure consistency is maintained as much as possible

### 5. Testing

- Test with database available
- Test with database unavailable
- Test with database that becomes unavailable then available again
- Verify correct operation in all scenarios

## Acceptance Criteria

1. Service starts successfully even when the database is unavailable
2. Public keys can be retrieved when the database is down
3. New keys are stored in the database when it becomes available again
4. Expired keys are properly managed in both storage systems
5. No changes are required to the usecases layer
6. All operations are properly logged for monitoring

This implementation will ensure the service remains operational during database outages, providing high availability for token exchange operations.

# Sonet 3.7 thinking
## Fault Tolerant Repository Implementation Task

Based on your plan, here's a detailed task for implementing a fault-tolerant repository for public keys:

## Task: Implement FaultTolerantPublicKeyRepository

Create a new repository implementation that provides fault tolerance when working with the database. The service should continue to operate even if the database is unavailable.

### Implementation Requirements:

1. Create a new file `internal/infrastructure/repository/faulttolerance/public_key.go` with the FaultTolerantPublicKeyRepository implementation

2. The repository should:
   - Use both Postgres (primary) and InMemory (fallback) repositories
   - Handle database connection failures gracefully
   - Cache public keys to ensure service availability during DB outages
   - Implement the same interface as existing repositories

3. Core functionalities:
   - **Create()**: Store the public key in both Postgres and InMemory cache
   - **Get()**: 
     - Try to get the key from Postgres first
     - If Postgres is down, fall back to InMemory cache
     - When retrieving from Postgres, update the InMemory cache if needed
   - **DeleteExpired()**: Delete expired keys from both repositories
   - **LoadAllKeysFromDB()**: Load all valid keys from DB into cache at startup
   - **IsDBAvailable()**: Check if the database is available

4. Error handling:
   - Log database errors but don't propagate them if the operation succeeds in the cache
   - Implement appropriate error wrapping for debugging
   - Handle DB connectivity issues without affecting service availability

5. Startup behavior:
   - The service should start even when the database is unavailable
   - When the DB becomes available, the repository should start using it

### Implementation Example:

```go
// FaultTolerantPublicKeyRepository implements publicKeyRepository interface
// providing fault tolerance when the primary database is unavailable
type FaultTolerantPublicKeyRepository struct {
    dbRepo    *postgres.PublicKeyRepository     // Primary storage
    cacheRepo *inmemory.PublicKeyRepository     // Fallback storage
    isDBAvailable bool                          // Tracks DB availability
    mu        sync.RWMutex                      // Mutex for thread safety
}

// NewFaultTolerantPublicKeyRepository creates a new instance of FaultTolerantPublicKeyRepository
func NewFaultTolerantPublicKeyRepository(
    dbRepo *postgres.PublicKeyRepository,
    cacheRepo *inmemory.PublicKeyRepository,
) *FaultTolerantPublicKeyRepository {
    repo := &FaultTolerantPublicKeyRepository{
        dbRepo:    dbRepo,
        cacheRepo: cacheRepo,
        isDBAvailable: dbRepo != nil,
    }
    
    // Load initial data from DB if available
    if repo.isDBAvailable {
        if err := repo.loadAllKeysFromDB(context.Background()); err != nil {
            // Log error but continue
            repo.isDBAvailable = false
        }
    }
    
    return repo
}
```

### Integration with `cmd/server/main.go`:

Update the `createRepositories` function to initialize and return the FaultTolerantPublicKeyRepository:

```go
func createRepositories(ctx context.Context, postgresCfg configs.Postgres) (*database.Postgres, publicKeyRepo, error) {
    // Create in-memory repository
    inMemoryRepo := inmemory.NewPublicKeyRepository(time.Now)
    
    // Create postgres repository if enabled
    var postgresDB *database.Postgres
    var dbRepo *postgres.PublicKeyRepository
    
    if postgresCfg.IsEnabled {
        var err error
        postgresDB, err = database.NewPostgres(ctx, postgresCfg.DSN)
        if err != nil {
            slog.WarnContext(ctx, "Failed to connect to Postgres, running in memory-only mode", 
                slog.String("error", err.Error()))
        } else {
            dbRepo = postgres.NewPublicKeyRepository(postgresDB.Connection())
        }
    } else {
        slog.InfoContext(ctx, "Postgres is disabled, using in-memory repository only")
    }
    
    // Create fault-tolerant repository
    faultTolerantRepo := faulttolerance.NewFaultTolerantPublicKeyRepository(dbRepo, inMemoryRepo)
    
    return postgresDB, faultTolerantRepo, nil
}
```

### Testing Requirements:
- Test failure scenarios where the database is unavailable
- Test recovery scenarios where the database becomes available again
- Test data consistency between cache and database

This implementation should provide the desired fault tolerance while maintaining the same interface for the UseCases layer.

# Gemini 2.5 pro
## Implementing Fault Tolerance for Database Operations

Based on your plan, here's a detailed task breakdown for implementing fault-tolerant operations with the database repository.

## Task: Implement FaultTolerantPublicKeyRepository

### Requirements:
1. Create a fault-tolerant repository that implements the `publicKeyRepository` interface
2. Ensure service can continue working when the database is unavailable
3. Don't modify the `usecases` layer
4. Repository should handle database unavailability gracefully

### Implementation Details:

1. Create a new file `internal/infrastructure/repository/faulttolerance/public_key.go` with:

```go
package faulttolerance

import (
	"context"
	"errors"
	"log/slog"
	"sync"
	"time"

	"gitlab-private.wildberries.ru/cloud/token-exchange/internal/infrastructure/repository/inmemory"
	"gitlab-private.wildberries.ru/cloud/token-exchange/internal/infrastructure/repository/postgres"
	"gitlab-private.wildberries.ru/cloud/token-exchange/internal/usecases/domain"
)

// FaultTolerantPublicKeyRepository implements fault tolerance for database operations.
// It uses an in-memory cache as a fallback when the database is unavailable.
type FaultTolerantPublicKeyRepository struct {
	dbRepo        *postgres.PublicKeyRepository
	memRepo       *inmemory.PublicKeyRepository
	dbAvailable   bool
	mu            sync.RWMutex
	initialized   bool
	cacheSyncLock sync.Mutex
}

// Create adds a public key to both the database and in-memory repositories.
// If the database is unavailable, it only stores in memory and logs the error.
func (r *FaultTolerantPublicKeyRepository) Create(ctx context.Context, publicKey domain.PublicKey) error {
	// Always try to write to the in-memory repository first
	if err := r.memRepo.Create(ctx, publicKey); err != nil {
		slog.WarnContext(ctx, "Failed to create public key in memory cache", 
			slog.String("id", publicKey.ID), 
			slog.String("error", err.Error()))
	}

	// Try to write to the database if it's available
	r.mu.RLock()
	dbAvailable := r.dbAvailable && r.dbRepo != nil
	r.mu.RUnlock()

	if dbAvailable {
		if err := r.dbRepo.Create(ctx, publicKey); err != nil {
			slog.ErrorContext(ctx, "Failed to create public key in database", 
				slog.String("id", publicKey.ID), 
				slog.String("error", err.Error()))
			
			// Mark database as unavailable on error
			r.markDatabaseUnavailable()
			return nil // Don't return the error as we've stored in memory
		}
	}

	return nil
}

// Get retrieves a public key by id.
// It tries the database first if available, falling back to in-memory repository.
func (r *FaultTolerantPublicKeyRepository) Get(ctx context.Context, id string) (*domain.PublicKey, error) {
	r.mu.RLock()
	dbAvailable := r.dbAvailable && r.dbRepo != nil
	r.mu.RUnlock()

	// Try to initialize cache from database if not yet initialized
	if !r.initialized {
		r.ensureInitialized(ctx)
	}

	// Try to get from database if available
	if dbAvailable {
		key, err := r.dbRepo.Get(ctx, id)
		if err == nil {
			// Check if key exists in memory cache, add if missing
			memKey, memErr := r.memRepo.Get(ctx, id)
			if memErr != nil || memKey == nil {
				// Add to memory cache
				if err := r.memRepo.Create(ctx, *key); err != nil {
					slog.WarnContext(ctx, "Failed to cache database key in memory", 
						slog.String("id", id), 
						slog.String("error", err.Error()))
				}
			}
			return key, nil
		}
		
		// If database failed for a reason other than key not found, mark as unavailable
		if !errors.Is(err, usecaseserrors.ErrObjectDoesNotExist) {
			slog.ErrorContext(ctx, "Database error during key retrieval, falling back to memory cache", 
				slog.String("id", id), 
				slog.String("error", err.Error()))
			r.markDatabaseUnavailable()
			// Continue to memory repository...
		} else {
			// Key truly doesn't exist
			return nil, err
		}
	}

	// Fallback to memory repository
	return r.memRepo.Get(ctx, id)
}

// DeleteExpired removes expired public keys from both repositories.
func (r *FaultTolerantPublicKeyRepository) DeleteExpired(ctx context.Context) error {
	// Always clean up the memory repository
	if err := r.memRepo.DeleteExpired(ctx); err != nil {
		slog.WarnContext(ctx, "Failed to delete expired keys from memory cache", 
			slog.String("error", err.Error()))
	}

	// Try to clean up the database if it's available
	r.mu.RLock()
	dbAvailable := r.dbAvailable && r.dbRepo != nil
	r.mu.RUnlock()

	if dbAvailable {
		if err := r.dbRepo.DeleteExpired(ctx); err != nil {
			slog.ErrorContext(ctx, "Failed to delete expired keys from database", 
				slog.String("error", err.Error()))
			r.markDatabaseUnavailable()
			return nil // Don't propagate the error since we've cleaned memory
		}
	}

	return nil
}

// markDatabaseUnavailable marks the database as unavailable
func (r *FaultTolerantPublicKeyRepository) markDatabaseUnavailable() {
	r.mu.Lock()
	defer r.mu.Unlock()
	
	r.dbAvailable = false
	
	// Start a background health check to restore when DB becomes available
	go r.startHealthCheck()
}

// startHealthCheck periodically checks if the database becomes available again
func (r *FaultTolerantPublicKeyRepository) startHealthCheck() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for range ticker.C {
		if r.checkDatabaseHealth() {
			break // Stop health check when DB is available
		}
	}
}

// checkDatabaseHealth checks if the database is healthy and updates status
func (r *FaultTolerantPublicKeyRepository) checkDatabaseHealth() bool {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Skip if database repository is nil
	if r.dbRepo == nil {
		return false
	}

	// Try a simple database operation
	if _, err := r.dbRepo.GetAll(ctx); err != nil {
		slog.WarnContext(ctx, "Database health check failed", slog.String("error", err.Error()))
		return false
	}

	// DB is available, update status
	r.mu.Lock()
	defer r.mu.Unlock()
	r.dbAvailable = true
	
	// If DB became available, trigger a cache sync
	go r.syncCacheFromDB(context.Background())
	
	slog.InfoContext(ctx, "Database connection restored")
	return true
}

// ensureInitialized makes sure the cache is populated from the database when available
func (r *FaultTolerantPublicKeyRepository) ensureInitialized(ctx context.Context) {
	r.cacheSyncLock.Lock()
	defer r.cacheSyncLock.Unlock()

	if r.initialized {
		return
	}

	// Try to load all keys from database
	r.syncCacheFromDB(ctx)
	
	r.initialized = true
}

// syncCacheFromDB synchronizes all valid public keys from database to memory cache
func (r *FaultTolerantPublicKeyRepository) syncCacheFromDB(ctx context.Context) {
	if r.dbRepo == nil {
		return
	}

	keys, err := r.dbRepo.GetAll(ctx)
	if err != nil {
		slog.ErrorContext(ctx, "Failed to retrieve public keys from database for cache sync", 
			slog.String("error", err.Error()))
		return
	}

	slog.InfoContext(ctx, "Syncing public keys from database to memory cache", 
		slog.Int("key_count", len(keys)))

	for _, key := range keys {
		if err := r.memRepo.Create(ctx, key); err != nil {
			// Skip keys that already exist in memory
			if !errors.Is(err, errors.New("object already exist")) {
				slog.WarnContext(ctx, "Failed to add database key to memory cache during sync", 
					slog.String("id", key.ID), 
					slog.String("error", err.Error()))
			}
		}
	}
}

// NewFaultTolerantPublicKeyRepository creates a new fault-tolerant repository.
// The database repository can be nil if the database is unavailable at startup.
func NewFaultTolerantPublicKeyRepository(dbRepo *postgres.PublicKeyRepository) *FaultTolerantPublicKeyRepository {
	repo := &FaultTolerantPublicKeyRepository{
		dbRepo:      dbRepo,
		memRepo:     inmemory.NewPublicKeyRepository(time.Now),
		dbAvailable: dbRepo != nil,
		initialized: false,
	}

	// Asynchronously try to initialize cache from database
	go repo.ensureInitialized(context.Background())

	return repo
}
```

2. Update `cmd/server/main.go:createRepositories` to implement the fault tolerance pattern:

```go
func createRepositories(
	ctx context.Context,
	postgresCfg configs.Postgres,
) (*database.Postgres, publicKeyRepo, error) {
	var postgresDB *database.Postgres
	var dbRepo *postgres.PublicKeyRepository

	if postgresCfg.IsEnabled {
		var err error
		postgresDB, err = database.NewPostgres(ctx, postgresCfg.DSN)
		if err != nil {
			slog.WarnContext(ctx, "Failed to connect to PostgreSQL database, will operate in memory-only mode", 
				slog.String("error", err.Error()))
			// Continue without database
		} else {
			dbRepo = postgres.NewPublicKeyRepository(postgresDB.Connection())
		}
	} else {
		slog.InfoContext(ctx, "PostgreSQL is disabled, using in-memory mode")
	}

	// Create fault-tolerant repository that can work with or without database
	publicKeyRepository := faulttolerance.NewFaultTolerantPublicKeyRepository(dbRepo)
	return postgresDB, publicKeyRepository, nil
}
```

### Key Implementation Notes:

1. **Multi-Layer Design**: 
   - Uses both PostgreSQL and in-memory repositories
   - Gracefully handles database unavailability

2. **Fault Management**:
   - Automatically detects database failures
   - Marks database as unavailable on errors
   - Implements background health checks to restore database connection

3. **Cache Initialization and Synchronization**:
   - Loads all valid public keys from database into memory on startup
   - Ensures keys found in database are added to memory cache
   - Synchronizes cache when database becomes available again

4. **Error Handling Strategy**:
   - Always attempts to use memory cache as a fallback
   - Does not propagate database errors to calling code
   - Logs appropriate warning and error messages

5. **Operational Considerations**:
   - Service can start with database unavailable
   - Writes happen to both repositories when possible
   - Reads prefer database but fall back to memory

This implementation ensures the service remains operational even when the database is down, while maintaining data integrity by synchronizing between repositories when possible.